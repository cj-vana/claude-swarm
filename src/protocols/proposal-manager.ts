/**
 * Proposal Manager - Manages LLM-generated protocol proposals with approval workflow
 *
 * This module provides a complete workflow for protocol proposals:
 * 1. Submit proposals (from LLM or users)
 * 2. Validate against base constraints
 * 3. Review with risk assessment
 * 4. Approve or reject with reasoning
 * 5. Auto-register approved protocols
 *
 * @see proposal-validator.ts for validation logic
 * @see base-constraints.ts for base constraint definitions
 */

import * as fs from "fs";
import * as path from "path";
import { z } from "zod";
import type { Protocol } from "./schema.js";
import { ProtocolSchema } from "./schema.js";
import { ProtocolRegistry } from "./registry.js";
import {
  ProposalValidator,
  type ProposalValidationResult,
  type RiskAssessment,
} from "./proposal-validator.js";
import { getBaseConstraints } from "./base-constraints.js";
import type { BaseConstraints } from "./schema.js";

// ============================================================================
// Proposal Types
// ============================================================================

/**
 * Status of a protocol proposal
 */
export type ProposalStatus =
  | "pending"      // Awaiting review
  | "reviewing"    // Currently being reviewed
  | "approved"     // Approved and registered
  | "rejected"     // Rejected with reason
  | "expired";     // Auto-expired after timeout

/**
 * Source of a protocol proposal
 */
export type ProposalSource =
  | "llm"          // Generated by LLM
  | "user"         // Submitted by user
  | "system"       // System-generated (e.g., from templates)
  | "import";      // Imported from external source

/**
 * A protocol proposal with metadata and validation results
 */
export interface ProtocolProposal {
  /** Unique proposal ID */
  id: string;

  /** The proposed protocol */
  protocol: Protocol;

  /** Current status */
  status: ProposalStatus;

  /** Source of the proposal */
  source: ProposalSource;

  /** Optional description of why this protocol is needed */
  description?: string;

  /** Optional rationale for the protocol design */
  rationale?: string;

  /** Validation result from ProposalValidator */
  validation: ProposalValidationResult;

  /** Who submitted the proposal */
  submittedBy?: string;

  /** When the proposal was submitted */
  submittedAt: string;

  /** Who reviewed the proposal */
  reviewedBy?: string;

  /** When the proposal was reviewed */
  reviewedAt?: string;

  /** Approval/rejection reason */
  reviewReason?: string;

  /** Expiration time for pending proposals */
  expiresAt?: string;

  /** Tags for categorization */
  tags?: string[];

  /** Priority for review queue */
  priority: number;
}

/**
 * Review result when approving/rejecting a proposal
 */
export interface ProposalReview {
  proposalId: string;
  decision: "approve" | "reject";
  reason: string;
  reviewedBy?: string;
  modifications?: Partial<Protocol>;
}

// ============================================================================
// Zod Schemas
// ============================================================================

export const ProposalStatusSchema = z.enum([
  "pending",
  "reviewing",
  "approved",
  "rejected",
  "expired",
]);

export const ProposalSourceSchema = z.enum([
  "llm",
  "user",
  "system",
  "import",
]);

export const ProtocolProposalSchema = z.object({
  id: z.string(),
  protocol: ProtocolSchema,
  status: ProposalStatusSchema,
  source: ProposalSourceSchema,
  description: z.string().optional(),
  rationale: z.string().optional(),
  validation: z.object({
    isValid: z.boolean(),
    isFixable: z.boolean(),
    issues: z.array(z.any()),
    proposedFixes: z.array(z.any()),
    riskAssessment: z.any(),
    baseConstraintValidation: z.any(),
    validatedProtocol: z.any().nullable(),
    validatedAt: z.string(),
    validationTimeMs: z.number(),
  }),
  submittedBy: z.string().optional(),
  submittedAt: z.string(),
  reviewedBy: z.string().optional(),
  reviewedAt: z.string().optional(),
  reviewReason: z.string().optional(),
  expiresAt: z.string().optional(),
  tags: z.array(z.string()).optional(),
  priority: z.number(),
});

// ============================================================================
// Proposal Manager State
// ============================================================================

interface ProposalManagerState {
  proposals: Record<string, ProtocolProposal>;
  lastUpdated: string;
}

const ProposalManagerStateSchema = z.object({
  proposals: z.record(ProtocolProposalSchema),
  lastUpdated: z.string(),
});

// Default proposal expiration (24 hours)
const DEFAULT_EXPIRATION_MS = 24 * 60 * 60 * 1000;

// Maximum pending proposals
const MAX_PENDING_PROPOSALS = 100;

/**
 * Generate unique proposal ID
 */
function generateProposalId(): string {
  return `prop-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
}

// ============================================================================
// Proposal Manager Class
// ============================================================================

/**
 * ProposalManager - Manages the lifecycle of protocol proposals
 */
export class ProposalManager {
  private readonly projectDir: string;
  private readonly proposalsDir: string;
  private readonly stateFile: string;
  private readonly registry: ProtocolRegistry;
  private readonly validator: ProposalValidator;

  // In-memory state
  private proposals: Map<string, ProtocolProposal> = new Map();

  constructor(
    projectDir: string,
    registry: ProtocolRegistry,
    validator?: ProposalValidator
  ) {
    this.projectDir = projectDir;
    this.proposalsDir = path.join(
      projectDir,
      ".claude",
      "orchestrator",
      "proposals"
    );
    this.stateFile = path.join(this.proposalsDir, "proposals.json");
    this.registry = registry;
    this.validator = validator ?? new ProposalValidator();

    // Ensure proposals directory exists
    if (!fs.existsSync(this.proposalsDir)) {
      fs.mkdirSync(this.proposalsDir, { recursive: true });
    }

    // Load existing state
    this.load();

    // Clean up expired proposals
    this.cleanupExpired();
  }

  // ==========================================================================
  // State Management
  // ==========================================================================

  /**
   * Load state from disk
   */
  private load(): void {
    if (!fs.existsSync(this.stateFile)) {
      return;
    }

    try {
      const data = fs.readFileSync(this.stateFile, "utf-8");
      const parsed = JSON.parse(data);
      ProposalManagerStateSchema.parse(parsed);
      const validated = parsed as ProposalManagerState;

      this.proposals = new Map(Object.entries(validated.proposals));
    } catch (error) {
      console.error("Error loading proposals (file may be corrupted):", error);
      this.proposals = new Map();
    }
  }

  /**
   * Save state to disk using atomic write
   */
  private save(): void {
    const state: ProposalManagerState = {
      proposals: Object.fromEntries(this.proposals),
      lastUpdated: new Date().toISOString(),
    };

    const tempFile = `${this.stateFile}.tmp.${Date.now()}`;
    try {
      fs.writeFileSync(tempFile, JSON.stringify(state, null, 2));
      fs.renameSync(tempFile, this.stateFile);
    } catch (error) {
      try {
        fs.unlinkSync(tempFile);
      } catch {
        // Ignore cleanup errors
      }
      throw error;
    }
  }

  /**
   * Clean up expired proposals
   */
  private cleanupExpired(): void {
    const now = new Date();
    let changed = false;

    for (const [id, proposal] of this.proposals.entries()) {
      if (proposal.status === "pending" && proposal.expiresAt) {
        const expiresAt = new Date(proposal.expiresAt);
        if (expiresAt < now) {
          proposal.status = "expired";
          changed = true;
        }
      }
    }

    if (changed) {
      this.save();
    }
  }

  // ==========================================================================
  // Proposal Submission
  // ==========================================================================

  /**
   * Submit a new protocol proposal
   */
  submit(options: {
    protocol: Protocol;
    source: ProposalSource;
    description?: string;
    rationale?: string;
    submittedBy?: string;
    tags?: string[];
    priority?: number;
    expirationMs?: number;
  }): ProtocolProposal {
    // Check pending proposal limit
    const pendingCount = Array.from(this.proposals.values()).filter(
      (p) => p.status === "pending"
    ).length;
    if (pendingCount >= MAX_PENDING_PROPOSALS) {
      throw new Error(
        `Maximum pending proposals (${MAX_PENDING_PROPOSALS}) reached. Review or reject existing proposals first.`
      );
    }

    // Validate the protocol
    const validation = this.validator.validate(options.protocol);

    // Calculate expiration
    const expirationMs = options.expirationMs ?? DEFAULT_EXPIRATION_MS;
    const expiresAt = new Date(Date.now() + expirationMs).toISOString();

    // Create proposal
    const proposal: ProtocolProposal = {
      id: generateProposalId(),
      protocol: options.protocol,
      status: "pending",
      source: options.source,
      description: options.description,
      rationale: options.rationale,
      validation,
      submittedBy: options.submittedBy,
      submittedAt: new Date().toISOString(),
      expiresAt,
      tags: options.tags,
      priority: options.priority ?? 50,
    };

    // Store
    this.proposals.set(proposal.id, proposal);
    this.save();

    return proposal;
  }

  /**
   * Submit a proposal from an LLM-generated protocol description
   * This is a convenience method for LLM integration
   */
  proposeFromLLM(options: {
    protocol: Protocol;
    description?: string;
    rationale?: string;
    priority?: number;
  }): ProtocolProposal {
    return this.submit({
      ...options,
      source: "llm",
      submittedBy: "llm",
    });
  }

  // ==========================================================================
  // Proposal Review
  // ==========================================================================

  /**
   * Get a proposal by ID
   */
  getProposal(proposalId: string): ProtocolProposal | undefined {
    return this.proposals.get(proposalId);
  }

  /**
   * Get all proposals with optional filtering
   */
  getProposals(options?: {
    status?: ProposalStatus;
    source?: ProposalSource;
    tags?: string[];
    limit?: number;
    offset?: number;
  }): ProtocolProposal[] {
    let filtered = Array.from(this.proposals.values());

    if (options?.status) {
      filtered = filtered.filter((p) => p.status === options.status);
    }
    if (options?.source) {
      filtered = filtered.filter((p) => p.source === options.source);
    }
    if (options?.tags && options.tags.length > 0) {
      filtered = filtered.filter(
        (p) => p.tags && options.tags!.some((t) => p.tags!.includes(t))
      );
    }

    // Sort by priority (higher first), then by submission time (newer first)
    filtered.sort((a, b) => {
      if (a.priority !== b.priority) {
        return b.priority - a.priority;
      }
      return new Date(b.submittedAt).getTime() - new Date(a.submittedAt).getTime();
    });

    // Apply pagination
    const offset = options?.offset ?? 0;
    const limit = options?.limit ?? filtered.length;
    return filtered.slice(offset, offset + limit);
  }

  /**
   * Get pending proposals ready for review
   */
  getPendingProposals(options?: {
    limit?: number;
    minPriority?: number;
  }): ProtocolProposal[] {
    let pending = this.getProposals({ status: "pending" });

    if (options?.minPriority !== undefined) {
      pending = pending.filter((p) => p.priority >= options.minPriority!);
    }

    if (options?.limit !== undefined) {
      pending = pending.slice(0, options.limit);
    }

    return pending;
  }

  /**
   * Mark a proposal as being reviewed
   */
  startReview(proposalId: string, reviewedBy?: string): ProtocolProposal {
    const proposal = this.proposals.get(proposalId);
    if (!proposal) {
      throw new Error(`Proposal '${proposalId}' not found`);
    }

    if (proposal.status !== "pending") {
      throw new Error(
        `Cannot review proposal in '${proposal.status}' status`
      );
    }

    proposal.status = "reviewing";
    proposal.reviewedBy = reviewedBy;
    this.save();

    return proposal;
  }

  /**
   * Approve a proposal and register the protocol
   */
  approve(review: ProposalReview): ProtocolProposal {
    const proposal = this.proposals.get(review.proposalId);
    if (!proposal) {
      throw new Error(`Proposal '${review.proposalId}' not found`);
    }

    if (proposal.status !== "pending" && proposal.status !== "reviewing") {
      throw new Error(
        `Cannot approve proposal in '${proposal.status}' status`
      );
    }

    // Apply any modifications
    let finalProtocol = proposal.protocol;
    if (review.modifications) {
      finalProtocol = {
        ...proposal.protocol,
        ...review.modifications,
      };
      // Re-validate with modifications
      const revalidation = this.validator.validate(finalProtocol);
      if (!revalidation.isValid) {
        throw new Error(
          `Modified protocol is not valid: ${revalidation.issues
            .filter((i) => i.type === "error")
            .map((i) => i.message)
            .join(", ")}`
        );
      }
    }

    // Register the protocol
    try {
      this.registry.register(finalProtocol, review.reviewedBy);
    } catch (error) {
      throw new Error(
        `Failed to register approved protocol: ${error instanceof Error ? error.message : String(error)}`
      );
    }

    // Update proposal status
    proposal.status = "approved";
    proposal.reviewedBy = review.reviewedBy;
    proposal.reviewedAt = new Date().toISOString();
    proposal.reviewReason = review.reason;
    proposal.protocol = finalProtocol;
    this.save();

    return proposal;
  }

  /**
   * Reject a proposal
   */
  reject(review: ProposalReview): ProtocolProposal {
    const proposal = this.proposals.get(review.proposalId);
    if (!proposal) {
      throw new Error(`Proposal '${review.proposalId}' not found`);
    }

    if (proposal.status !== "pending" && proposal.status !== "reviewing") {
      throw new Error(
        `Cannot reject proposal in '${proposal.status}' status`
      );
    }

    proposal.status = "rejected";
    proposal.reviewedBy = review.reviewedBy;
    proposal.reviewedAt = new Date().toISOString();
    proposal.reviewReason = review.reason;
    this.save();

    return proposal;
  }

  // ==========================================================================
  // Proposal Statistics
  // ==========================================================================

  /**
   * Get proposal statistics
   */
  getStats(): {
    total: number;
    pending: number;
    reviewing: number;
    approved: number;
    rejected: number;
    expired: number;
    bySource: Record<ProposalSource, number>;
    avgRiskScore: number;
    validProposals: number;
  } {
    const proposals = Array.from(this.proposals.values());

    const byStatus = {
      pending: 0,
      reviewing: 0,
      approved: 0,
      rejected: 0,
      expired: 0,
    };

    const bySource: Record<ProposalSource, number> = {
      llm: 0,
      user: 0,
      system: 0,
      import: 0,
    };

    let totalRiskScore = 0;
    let validCount = 0;

    for (const proposal of proposals) {
      byStatus[proposal.status]++;
      bySource[proposal.source]++;
      totalRiskScore += proposal.validation.riskAssessment.overallScore;
      if (proposal.validation.isValid) {
        validCount++;
      }
    }

    return {
      total: proposals.length,
      ...byStatus,
      bySource,
      avgRiskScore:
        proposals.length > 0
          ? Math.round(totalRiskScore / proposals.length)
          : 0,
      validProposals: validCount,
    };
  }

  // ==========================================================================
  // Proposal Management
  // ==========================================================================

  /**
   * Delete a proposal (only non-approved proposals)
   */
  delete(proposalId: string): void {
    const proposal = this.proposals.get(proposalId);
    if (!proposal) {
      throw new Error(`Proposal '${proposalId}' not found`);
    }

    if (proposal.status === "approved") {
      throw new Error("Cannot delete an approved proposal");
    }

    this.proposals.delete(proposalId);
    this.save();
  }

  /**
   * Clear all expired and rejected proposals
   */
  cleanup(): { cleared: number } {
    let cleared = 0;

    for (const [id, proposal] of this.proposals.entries()) {
      if (proposal.status === "expired" || proposal.status === "rejected") {
        this.proposals.delete(id);
        cleared++;
      }
    }

    if (cleared > 0) {
      this.save();
    }

    return { cleared };
  }

  /**
   * Re-validate a proposal with current base constraints
   */
  revalidate(proposalId: string): ProtocolProposal {
    const proposal = this.proposals.get(proposalId);
    if (!proposal) {
      throw new Error(`Proposal '${proposalId}' not found`);
    }

    if (proposal.status !== "pending" && proposal.status !== "reviewing") {
      throw new Error(`Cannot revalidate proposal in '${proposal.status}' status`);
    }

    proposal.validation = this.validator.validate(proposal.protocol);
    this.save();

    return proposal;
  }

  /**
   * Get the base constraints being used for validation
   */
  getBaseConstraints(): BaseConstraints {
    return this.validator.getBaseConstraints();
  }
}

// ============================================================================
// Factory Functions
// ============================================================================

/**
 * Create a proposal manager for a project
 */
export function createProposalManager(
  projectDir: string,
  registry: ProtocolRegistry,
  options?: {
    customValidator?: ProposalValidator;
  }
): ProposalManager {
  return new ProposalManager(projectDir, registry, options?.customValidator);
}

// Singleton instance cache per project
const managerCache = new Map<string, ProposalManager>();
const registryCache = new Map<string, ProtocolRegistry>();

/**
 * Get or create a proposal manager for a project (cached singleton)
 */
export function getProposalManager(projectDir: string): ProposalManager {
  const existing = managerCache.get(projectDir);
  if (existing) {
    return existing;
  }

  let registry = registryCache.get(projectDir);
  if (!registry) {
    registry = new ProtocolRegistry(projectDir);
    registryCache.set(projectDir, registry);
  }

  const manager = new ProposalManager(projectDir, registry);
  managerCache.set(projectDir, manager);
  return manager;
}

/**
 * Clear the manager cache (for testing)
 */
export function clearProposalManagerCache(): void {
  managerCache.clear();
  registryCache.clear();
}
